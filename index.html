<script>
        // --- CONFIGURATION ---
        const firebaseConfig = {
          apiKey: "AIzaSyCFmwO9aa5RZgOwQ5b3tN8NPha_1UfrCjA",
          authDomain: "notes-b4daa.firebaseapp.com",
          projectId: "notes-b4daa",
          storageBucket: "notes-b4daa.firebasestorage.app",
          messagingSenderId: "372433592521",
          appId: "1:372433592521:web:348b2558084299be1a6d18"
        };

        try { firebase.initializeApp(firebaseConfig); } catch(e) { console.error(e); }
        const auth = firebase.auth();
        const db = firebase.firestore();

        // --- STATE ---
        let state = {
            user: null, 
            docId: null,      // The ID of the doc we are viewing
            docOwnerId: null, // The UID of the person who OWNS the doc
            activeFilter: 'all', 
            folders: [], 
            docs: [],
            isFav: false, 
            saveTimer: null, 
            firstLoad: true,
            unsubscribeDoc: null, // To stop listening when switching docs
            unsubscribeCursors: null,
            myColor: '#' + Math.floor(Math.random()*16777215).toString(16) // Random cursor color
        };

        // --- DOM ELEMENTS ---
        const els = {
            loadingScreen: document.getElementById('loading-screen'),
            authScreen: document.getElementById('auth-screen'), 
            authBox: document.getElementById('auth-box'),
            dashboard: document.getElementById('dashboard-screen'),
            sidebar: document.getElementById('sidebar'),
            email: document.getElementById('email'), pass: document.getElementById('password'),
            authError: document.getElementById('auth-error'), docList: document.getElementById('doc-list'),
            folderList: document.getElementById('folder-list'), folderSelect: document.getElementById('folder-select'),
            title: document.getElementById('doc-title'), editorWrapper: document.getElementById('editor-wrapper'),
            status: document.getElementById('save-status'), favBtn: document.getElementById('fav-btn'),
            delBtn: document.getElementById('delete-btn'), downBtn: document.getElementById('download-btn'),
            userEmail: document.getElementById('user-email'),
            mobileFolderMenu: document.getElementById('mobile-folder-menu'),
            mobileFolderListItems: document.getElementById('mobile-folder-list-items'),
            sunIcon: document.getElementById('sun-icon'), moonIcon: document.getElementById('moon-icon'),
            previewBanner: document.getElementById('preview-banner'),
            mobileMenuDropdown: document.getElementById('mobile-menu-dropdown'),
            mobileFavIcon: document.getElementById('mobile-fav-icon'), mobileFavText: document.getElementById('mobile-fav-text'),
            loggedInControls: document.getElementById('logged-in-controls'),
            guestDownloadBtn: document.getElementById('guest-download-btn'),
            hamburgerBtn: document.getElementById('hamburger-btn'),
            authCancelContainer: document.getElementById('auth-cancel-container'),
            paperContainer: document.getElementById('paper-container') // For cursors
        };

        // --- THEME ---
        function initTheme() {
            const savedTheme = localStorage.getItem('theme');
            applyTheme(savedTheme === 'dark');
        }
        function applyTheme(isDark) {
            if (isDark) {
                document.documentElement.classList.add('dark');
                els.sunIcon.classList.remove('hidden'); els.moonIcon.classList.add('hidden');
            } else {
                document.documentElement.classList.remove('dark');
                els.sunIcon.classList.add('hidden'); els.moonIcon.classList.remove('hidden');
            }
        }
        function toggleTheme() {
            document.documentElement.classList.toggle('dark');
            const isDark = document.documentElement.classList.contains('dark');
            localStorage.setItem('theme', isDark ? 'dark' : 'light');
            applyTheme(isDark);
            if(state.user) {
                db.collection('users').doc(state.user.uid).set({ settings: { theme: isDark ? 'dark' : 'light' } }, { merge: true });
            }
        }
        
        // --- EDITOR INIT ---
        var quill = new Quill('#editor-container', {
            theme: 'snow', placeholder: 'Start writing...',
            modules: { 
                toolbar: [
                    [{'header':[1,2,3,false]}], 
                    ['bold','italic','underline','strike', {'color':[]},{'background':[]}], 
                    [{'list':'ordered'},{'list':'bullet'}, {'list': 'check'}], 
                    [{'align':[]}], ['image','link','clean']
                ] 
            }
        });

        // --- CURSOR LOGIC ---
        // Create a layer for cursors
        const cursorLayer = document.createElement('div');
        cursorLayer.id = 'cursor-layer';
        cursorLayer.style.position = 'absolute';
        cursorLayer.style.top = '0'; cursorLayer.style.left = '0';
        cursorLayer.style.pointerEvents = 'none'; // Click through
        cursorLayer.style.zIndex = '10';
        els.paperContainer.appendChild(cursorLayer);

        function updateMyCursor(range) {
            if (!state.user || !state.docId || !state.docOwnerId || !range) return;
            // Write to the Owner's database
            db.collection('users').doc(state.docOwnerId).collection('docs').doc(state.docId)
              .collection('presence').doc(state.user.uid).set({
                  name: state.user.email.split('@')[0],
                  color: state.myColor,
                  range: range,
                  updatedAt: firebase.firestore.FieldValue.serverTimestamp()
              });
        }

        quill.on('selection-change', (range) => { if(range) updateMyCursor(range); });
        
        // Cleanup old cursors (if needed) and render new ones
        function renderCursors(snapshot) {
            cursorLayer.innerHTML = ''; // Clear old
            snapshot.forEach(doc => {
                const data = doc.data();
                if (doc.id === state.user?.uid) return; // Don't show my own cursor

                // Check if cursor is recent (active in last 5 mins)
                // In a real app, use a shorter timeout
                
                if (data.range) {
                    const bounds = quill.getBounds(data.range.index);
                    if(!bounds) return;

                    const flag = document.createElement('div');
                    flag.style.position = 'absolute';
                    flag.style.left = bounds.left + 'px';
                    flag.style.top = (bounds.top + 96) + 'px'; // +96 because of quill padding
                    flag.style.borderLeft = `2px solid ${data.color}`;
                    flag.style.height = bounds.height + 'px';
                    
                    const label = document.createElement('div');
                    label.textContent = data.name;
                    label.style.background = data.color;
                    label.style.color = '#fff';
                    label.style.fontSize = '10px';
                    label.style.padding = '2px 4px';
                    label.style.borderRadius = '3px';
                    label.style.position = 'absolute';
                    label.style.top = '-18px';
                    label.style.left = '-2px';
                    label.style.whiteSpace = 'nowrap';
                    
                    flag.appendChild(label);
                    cursorLayer.appendChild(flag);
                }
            });
        }

        // --- ROUTING & SHARING ---
        async function checkUrlForShare() {
            const urlParams = new URLSearchParams(window.location.search);
            const ownerId = urlParams.get('o'); // Owner ID
            const docId = urlParams.get('d');   // Doc ID
            
            if (ownerId && docId) {
                // Scenario 1: It's MY link
                if (state.user && state.user.uid === ownerId) {
                    window.history.replaceState({}, document.title, window.location.pathname); // Clean URL
                    openDoc(docId, null, ownerId); // Open normally
                    return true;
                }

                // Scenario 2: I am logged in, but it's someone else's link
                if (state.user) {
                    // Check if I already have this as a shortcut
                    const existing = state.docs.find(d => d.refDocId === docId);
                    if (existing) {
                        openDoc(existing.id, existing); // Open my shortcut
                        window.history.replaceState({}, document.title, window.location.pathname);
                        return true;
                    }
                    
                    // Ask to Import (Create Link)
                    if(confirm("Add this shared note to your workspace?")) {
                        await createShortcut(ownerId, docId);
                    } else {
                        // View as Guest
                        openGuestMode(ownerId, docId);
                    }
                    window.history.replaceState({}, document.title, window.location.pathname);
                    return true;
                }

                // Scenario 3: Not logged in (Guest)
                openGuestMode(ownerId, docId);
                return true;
            }
            return false;
        }

        function openGuestMode(ownerId, docId) {
            state.isGuest = true;
            els.authScreen.classList.add('hidden');
            els.dashboard.classList.remove('hidden');
            els.dashboard.classList.add('animate-fade-in');
            
            // Adjust UI
            els.loggedInControls.classList.add('hidden');
            els.sidebar.classList.add('hidden'); els.hamburgerBtn.classList.add('hidden');
            els.guestDownloadBtn.classList.remove('hidden');
            els.previewBanner.classList.remove('hidden');
            els.previewBanner.querySelector('span').textContent = "üëÄ Live Guest Mode";

            // Initialize Live Connection
            openDoc(docId, null, ownerId);
        }

        async function createShortcut(ownerId, docId) {
            // Fetch title first
            let title = "Shared Note";
            try {
                const snap = await db.collection('users').doc(ownerId).collection('docs').doc(docId).get();
                if(snap.exists) title = snap.data().title;
            } catch(e) {}

            await db.collection('users').doc(state.user.uid).collection('docs').add({
                isLink: true,
                refOwnerId: ownerId,
                refDocId: docId,
                title: title + " (Shared)",
                updatedAt: firebase.firestore.FieldValue.serverTimestamp()
            });
            alert("Added to your notes!");
        }

        // --- AUTH ---
        auth.onAuthStateChanged(async u => {
            state.user = u;
            if (u) {
                state.isGuest = false;
                els.userEmail.textContent = u.email;
                els.authScreen.classList.add('hidden');
                els.dashboard.classList.remove('hidden');
                els.previewBanner.classList.add('hidden');
                els.loggedInControls.classList.remove('hidden');
                els.sidebar.classList.remove('hidden');
                els.hamburgerBtn.classList.remove('hidden');
                
                initData();
                setTimeout(() => checkUrlForShare(), 500); // Check URL after init
            } else {
                if(!checkUrlForShare()) {
                    els.authScreen.classList.remove('hidden');
                    els.authBox.classList.remove('opacity-0'); 
                }
            }
        });

        // Login UI Handlers
        document.getElementById('auth-form').onsubmit = (e) => {
            e.preventDefault();
            auth.signInWithEmailAndPassword(els.email.value, els.pass.value).catch(e => els.authError.textContent = "Error: " + e.message);
        };
        document.getElementById('signup-btn').onclick = () => auth.createUserWithEmailAndPassword(els.email.value, els.pass.value).catch(e => els.authError.textContent = e.message);
        document.getElementById('logout-btn').onclick = () => { auth.signOut(); window.location.reload(); };
        window.openLoginForGuest = () => { els.authScreen.classList.remove('hidden'); els.authBox.classList.remove('opacity-0'); els.authCancelContainer.classList.remove('hidden'); };
        window.closeLoginForGuest = () => { els.authScreen.classList.add('hidden'); };

        // --- DATA MGMT ---
        function initData() {
            if(!state.user) return;
            // Listen to Folders
            db.collection('users').doc(state.user.uid).collection('folders').orderBy('createdAt').onSnapshot(snap => {
                state.folders = snap.docs.map(d => ({id: d.id, ...d.data()}));
                renderFolders(); updateFolderSelect();
            });
            // Listen to Docs (Mix of My Docs and Shortcuts)
            db.collection('users').doc(state.user.uid).collection('docs').orderBy('updatedAt', 'desc').onSnapshot(snap => {
                state.docs = snap.docs.map(d => ({id: d.id, ...d.data()}));
                renderDocs();
                // Auto-open first doc if fresh load
                if (state.firstLoad && !state.docId && state.docs.length > 0) {
                    state.firstLoad = false;
                    openDoc(state.docs[0].id, state.docs[0]);
                }
            });
        }

        // --- MAIN RENDERERS ---
        function renderFolders() {
            els.folderList.innerHTML = '';
            state.folders.forEach(f => {
                const div = document.createElement('div');
                const isActive = state.activeFilter === f.id;
                div.className = `flex justify-between items-center group p-2 rounded cursor-pointer transition ${isActive ? 'bg-white/10 text-white' : 'hover:bg-white/5 text-gray-400'}`;
                div.innerHTML = `<div class="flex items-center gap-2" onclick="filterDocs('${f.id}')"><span>${f.emoji}</span> <span class="text-sm">${f.name}</span></div><button onclick="deleteFolder('${f.id}')" class="text-gray-600 hover:text-red-400 opacity-0 group-hover:opacity-100 transition px-1">√ó</button>`;
                els.folderList.appendChild(div);
            });
        }

        function renderDocs() {
            els.docList.innerHTML = '';
            let filtered = state.docs;
            if(state.activeFilter === 'fav') filtered = state.docs.filter(d => d.isFavorite);
            else if (state.activeFilter !== 'all') filtered = state.docs.filter(d => d.folderId === state.activeFilter);

            filtered.forEach((d, index) => {
                const div = document.createElement('div');
                const isActive = d.id === state.docId;
                const isLink = d.isLink === true;
                
                div.className = `p-2 rounded mb-1 cursor-pointer transition flex flex-col border-l-2 doc-item-anim group relative ${isActive ? 'bg-[#252525] border-accent text-white' : 'border-transparent hover:bg-[#252525] text-gray-400'}`;
                div.style.animationDelay = `${index * 0.05}s`;
                
                // Duplicate Button (Only for my docs)
                const dupBtn = !isLink ? `<button onclick="event.stopPropagation(); duplicateDoc('${d.id}')" class="absolute right-2 top-2 opacity-0 group-hover:opacity-100 text-xs bg-gray-700 hover:bg-gray-600 text-white px-1.5 py-0.5 rounded" title="Duplicate">‚ùê</button>` : '';

                div.innerHTML = `
                    <div class="font-medium text-xs truncate flex items-center justify-between pr-6">
                        <span class="flex items-center gap-1">${isLink ? 'üîó' : ''} ${d.title || 'Untitled'}</span>
                    </div>
                    ${dupBtn}
                    <div class="text-[9px] opacity-60 flex justify-between mt-1 items-center">
                        <span>${d.updatedAt ? new Date(d.updatedAt.toDate()).toLocaleDateString() : 'Just now'}</span>
                        ${d.isFavorite ? '<span class="text-gold">‚òÖ</span>' : ''}
                    </div>`;
                div.onclick = () => openDoc(d.id, d);
                els.docList.appendChild(div);
            });
        }

        // --- OPEN DOC (THE CORE LOGIC) ---
        window.openDoc = (id, localData, overrideOwnerId) => {
            // 1. Unsubscribe from previous doc
            if (state.unsubscribeDoc) state.unsubscribeDoc();
            if (state.unsubscribeCursors) state.unsubscribeCursors();
            cursorLayer.innerHTML = ''; // Clear cursors

            state.docId = id; 
            
            // 2. Determine Owner
            // If localData has refOwnerId, it's a shortcut. If overrideOwnerId passed (Guest), use that. Else, it's mine.
            if (localData && localData.isLink) {
                state.docOwnerId = localData.refOwnerId;
                state.realDocId = localData.refDocId; // Actual Firestore ID
            } else if (overrideOwnerId) {
                state.docOwnerId = overrideOwnerId;
                state.realDocId = id;
            } else {
                state.docOwnerId = state.user.uid;
                state.realDocId = id;
            }

            // 3. UI Setup
            if(localData) {
                state.isFav = localData.isFavorite || false;
                els.folderSelect.value = localData.folderId || "";
                els.title.value = localData.title; 
            }
            els.editorWrapper.classList.remove('opacity-50', 'pointer-events-none');
            quill.enable();
            
            // Enable/Disable controls based on ownership
            const isMine = state.docOwnerId === state.user?.uid;
            els.delBtn.disabled = !isMine; 
            els.folderSelect.disabled = !isMine;
            els.favBtn.disabled = false; // Everyone can fav their view
            document.getElementById('share-btn').disabled = false;
            
            // 4. Listen to Real-Time Data (Live Sync)
            const docRef = db.collection('users').doc(state.docOwnerId).collection('docs').doc(state.realDocId);
            
            state.unsubscribeDoc = docRef.onSnapshot(doc => {
                if (!doc.exists) { els.title.value = "Document Deleted"; quill.disable(); return; }
                const data = doc.data();
                
                // Update Title
                if (document.activeElement !== els.title) els.title.value = data.title;
                
                // Update Content (Avoid overwriting if I am typing)
                // Note: Ideally use OT here. For this snippet, we check if content actually changed.
                const currentContent = JSON.stringify(quill.getContents());
                const newContent = JSON.stringify(data.content);
                
                if (currentContent !== newContent && !quill.hasFocus()) {
                    quill.setContents(data.content);
                }
                
                els.status.textContent = "Live Synced";
                updateFavIcon();
            });

            // 5. Listen to Cursors
            state.unsubscribeCursors = docRef.collection('presence').onSnapshot(renderCursors);
        };

        // --- ACTIONS ---
        window.createNewDoc = async () => {
            if(!state.user) return;
            const ref = await db.collection('users').doc(state.user.uid).collection('docs').add({
                title: 'Untitled Document', content: '', isFavorite: false, folderId: null,
                updatedAt: firebase.firestore.FieldValue.serverTimestamp()
            });
            openDoc(ref.id, {title: 'Untitled', content: ''});
        };

        window.duplicateDoc = async (id) => {
            if (!confirm("Duplicate this file?")) return;
            const doc = state.docs.find(d => d.id === id);
            if (!doc) return;
            
            await db.collection('users').doc(state.user.uid).collection('docs').add({
                title: doc.title + " (Copy)", 
                content: doc.content || "", // Requires content in list, or fetch it
                isFavorite: false, 
                folderId: doc.folderId,
                updatedAt: firebase.firestore.FieldValue.serverTimestamp()
            });
            alert("Duplicated!");
        };

        // --- SAVING ---
        // Trigger save on typing
        quill.on('text-change', (delta, old, source) => { 
            if (source === 'user') {
                 triggerSave(); 
            }
        });
        els.title.oninput = () => triggerSave();

        function triggerSave() {
            if(!state.docId) return;
            els.status.textContent = "Saving...";
            if(state.saveTimer) clearTimeout(state.saveTimer);
            state.saveTimer = setTimeout(saveToDb, 800); // Debounce
        }

        async function saveToDb() {
            if(!state.realDocId || !state.docOwnerId) return;
            
            try {
                // If I am guest, I write to OWNER'S DB
                await db.collection('users').doc(state.docOwnerId).collection('docs').doc(state.realDocId).set({
                    title: els.title.value, 
                    content: JSON.parse(JSON.stringify(quill.getContents())),
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                }, {merge: true});
                
                // If it's a shortcut (link), update the shortcut Title too so my sidebar is fresh
                if (state.docOwnerId !== state.user?.uid && state.docId !== state.realDocId) {
                     db.collection('users').doc(state.user.uid).collection('docs').doc(state.docId).update({
                        title: els.title.value
                     });
                }
                els.status.textContent = "Saved";
            } catch(e) { console.error(e); els.status.textContent = "Save Error"; }
        }

        window.shareCurrentNote = () => {
            // Generate link to REAL doc
            const url = new URL(window.location.href);
            url.searchParams.set('o', state.docOwnerId); // Owner
            url.searchParams.set('d', state.realDocId);  // Doc
            
            navigator.clipboard.writeText(url.toString()).then(() => {
                alert("Collaboration Link Copied!\n\nSend this to anyone. They can edit this exact file with you in real-time.");
            });
        };

        // --- HELPERS ---
        window.toggleFavorite = () => { 
            state.isFav = !state.isFav; updateFavIcon(); 
            // Save Fav status to MY doc reference (even if it's a shortcut)
            if(state.user) {
                db.collection('users').doc(state.user.uid).collection('docs').doc(state.docId).update({isFavorite: state.isFav});
            }
        };
        
        // (Keep previous helpers like downloadAsWord, toggleSidebar, toggleMobileMenu, etc.)
        window.downloadAsWord = () => {
            const title = els.title.value || "Document";
            const css = `<style>@page{size:A4;margin:1in;}body{font-family:'Times New Roman',serif;font-size:11pt;line-height:1.5;background-color:white!important;color:black!important;}</style>`;
            const html = `<html xmlns:o='urn:schemas-microsoft-com:office:office' xmlns:w='urn:schemas-microsoft-com:office:word'><head><meta charset='utf-8'><title>${title}</title>${css}</head><body>${quill.root.innerHTML}</body></html>`;
            const blob = new Blob(['\ufeff', html], {type: 'application/msword'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a"); a.href = url; a.download = title + ".doc"; a.click();
        };
        window.toggleSidebar = (f) => {
            const sb = document.getElementById('sidebar'), ov = document.getElementById('mobile-overlay');
            if(f===false || !sb.classList.contains('sidebar-closed')) { sb.classList.add('sidebar-closed'); sb.classList.remove('sidebar-open'); ov.classList.add('hidden'); }
            else { sb.classList.remove('sidebar-closed'); sb.classList.add('sidebar-open'); ov.classList.remove('hidden'); }
        };
        window.toggleMobileMenu = () => els.mobileMenuDropdown.classList.toggle('hidden');
        window.updateFavIcon = () => { els.favBtn.className = `hidden md:block p-2 rounded-full transition ${state.isFav ? 'text-gold' : 'text-muted hover:text-gold'}`; };
        window.focusEditor = () => { if(state.docId) quill.focus(); };
        window.deleteCurrentDoc = async () => {
             if(confirm("Delete this?")) {
                 await db.collection('users').doc(state.user.uid).collection('docs').doc(state.docId).delete();
                 window.location.reload();
             }
        };
        // Re-implement folder helpers
        window.createNewFolder = async () => {
            let name = prompt("Folder Name:"); if(!name) return;
            await db.collection('users').doc(state.user.uid).collection('folders').add({ name: name, emoji: 'üìÅ', createdAt: firebase.firestore.FieldValue.serverTimestamp() });
        };
        window.deleteFolder = async (id) => { if(confirm("Delete folder?")) await db.collection('users').doc(state.user.uid).collection('folders').doc(id).delete(); };
        window.filterDocs = (f) => { state.activeFilter = f; renderFolders(); renderDocs(); };
        window.updateFolderSelect = () => {
            els.folderSelect.innerHTML = '<option value="">No Folder</option>';
            state.folders.forEach(f => {
                const opt = document.createElement('option'); opt.value = f.id; opt.textContent = `${f.emoji} ${f.name}`; els.folderSelect.appendChild(opt);
            });
        };

        initTheme();
    </script>
